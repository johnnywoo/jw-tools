#!/bin/bash

# exit on first error
set -e

# loading variables with settings
source jw-settings

SELF="jw-git-helper"

usage()
{
cat << EOF
Usage: gh command [args]
Information:
  s       git status
  so      git remote show origin
  o       git remote update
  l       List of all branches. Auto-updates remote list.
  i       Show changes in current branch since master.
  dl      Show diff for last commit in the branch.
  sm      diff --stat, with master by default.
  dm      diff, with master by default.
  lm      log, with master by default.
Working:
  u       git pull
  ss      git stash
  sp      git stash pop
  r       git checkout --
  ok      Add everything and continue rebase.
Committing:
  a       git add
  m       git commit
  am      Commit all local changes.
  p       Push current branch to origin.
  fp      Push current branch to origin (with --force).
  mr [-n] Rename migrations from timestamps to ordered numbers
          (-n is no rename without committing).
Branches:
  b       Switch to a branch, creates it if necessary.
  bm      Switch to master branch. Also ulls the branch from origin too.
  g [-r]  Create a local branch from the remote one
          (-r is to rebase the branch to master).
          Will overwrite local branch completely.
Manipulation:
  rd      Deletes a remote branch.
  accept  Merge current branch into master, push master,
          then remove the branch from both servers.
          If a branch is specified, it will be grabbed before accepting.
  accept-all
          Accept all currently validated branches.
Trac:
  t       Show ticket info.
  te      Edit ticket description.
  fix     Close ticket (fixed).
EOF
}


# die if no args
[ $# = 0 ] && usage && exit 1


# exits with an error message
crap() { # error message
	[ "$1" ] && echo "$1" >&2
	exit 1
}

current_branch() {
	git branch --no-color 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}

guess_remote_branch() { # [branch name | ticket number]
	# no branch given: take current branch
	[ -z "$1" ] && current_branch && return
	# ticket number: try to find a branch for it
	if [[ "$1" =~ ^[0-9]+$ ]]
	then
		bs=$(git branch -r --no-color 2>/dev/null | sed -e 's/^ *origin\///' | grep -e '^[^ ]\+$' | grep "_${1}_")
		n=$(echo "$bs" | wc -l)
		if [ $n = "1" ]
		then
			echo "$bs"
			return
		fi
	fi
	# nothing is found, returning
	echo "$1"
}

# cuts first numeric sequence from the input
guess_ticket() { # ticket id or branch name
	echo "$1" | egrep -o '[0-9]+' | head -n 1
}

guess_author() { # [branch name]
	branch="$1"
	[ -z "$branch" ] && branch=$(current_branch)
	echo "$branch" | cut -d _ -f 1
}

# Takes input and converts it into ticket id.
# Grabs current branch name if no/empty args given.
# The script will die if no ticket id is found!
current_ticket() { # [ticket id or branch name]
	str="$1"
	[ -z "$str" ] && str=$(current_branch)
	ticket=$(guess_ticket "$str")
	[ -z "$ticket" ] && crap "Need ticket number"
	echo "$ticket"
}

current_project_root() {
	x=$(pwd)
	while [ "$x" != "/" ]
	do
		[ -d "$x/.git" ] && echo "$x" && return
		x=$(dirname "$x")
	done
	crap "Not in a git repository"
}

mark_branch_date() { # [ticket id]
	ticket="$1"
	[ -z "$ticket" ] && ticket=$(current_ticket 2>/dev/null)
	[ "$ticket" ] && wget -qO- "http://agalkin:ldflt,bkf@manager.trac.vps.loc/?action=touch_branch_date&id=$ticket" | tee /dev/stderr | grep -vq error	
}

find_migrations_path() {
	x=$(current_project_root)
	[ -d "$x/$JW_MIGRATIONS_PATH" ] && echo "$x/$JW_MIGRATIONS_PATH" || true # prevent the function from returning 1
}

propose_push() { # branch name
	if [ "$1" ] && $JW_CONFIRM_CMD -n "Do you want to push $1 to origin?"
	then
		git push origin "$1"
	fi
}

wait_for_git_lock() {
	pth="$(current_project_root)"
	lockf="$pth/.git/index.lock"
	if [ -e "$lockf" ]
	then
		echo -ne "Waiting for other process to release git lock.."
		while [ -e "$lockf" ]
		do
			echo -ne "."
			sleep 1
			# not waiting for too long
			rm -f "$lockf"
		done
		echo
	fi
}

require_trac() {
	[ "$JW_TRAC_CMD" ] || crap "No trac command specified, see jw-settings"
}

assign_ticket() { # ticket author
	echo "About to save ticket $1"
	echo " " | $JW_TRAC_CMD save "$1" owner:$2
}

display_status() { # status name regexp color
	x="$(echo "$1" | grep -E "$3" || true)"
	if [ "$x" ]; then
		echo "$2"
		oIFS="$IFS"; IFS=""
		while read line; do
			f1="${line:0:1}"
			f2="${line:1:1}"
			rest="${line:2}"
			[ "$f1" == "?" ] && f1="" && f2="?$f2"

			printf "% 3d. " "$n"
			echo -ne "\033[32m" # green
			echo -n "$f1"
			echo -ne "\033[31m" # red
			echo -n "$f2"
			echo -ne "\033[$4m" # given color
			echo "$rest"
			echo -ne "\033[0m" # white

			let "n+=1"
		done << EOF
$x
EOF
		IFS="$oIFS"
	fi
}

cmd="$1"
shift 1

case "$cmd" in
	s)
		wait_for_git_lock
		status="$(git status --porcelain)"
		n=1
		display_status "$status" 'Staged:'     '^[A-Z]'  32 # green
		display_status "$status" 'Not staged:' '^.[A-Z]' 31 # red
		display_status "$status" 'Untracked:'  '^\?'     31 # red
		;;
	so)
		wait_for_git_lock
		git remote show origin
		;;
	o)
		wait_for_git_lock
		git remote update
		;;
	l)
		wait_for_git_lock
		git remote update >/dev/null
		git branch -a
		;;
	i)
		wait_for_git_lock
		git log -M -C --stat --summary --abbrev-commit  master..
		;;
	dl)
		wait_for_git_lock
		git diff HEAD^..HEAD
		;;
	sm|stm)
		wait_for_git_lock
		arg="$1"
		[ -z "$arg" ] && arg="master.."
		git diff --stat "$arg"
		;;
	dm|dtm)
		wait_for_git_lock
		arg="$1"
		[ -z "$arg" ] && arg="master.."
		git diff "$arg"
		;;
	lm|ltm)
		wait_for_git_lock
		arg="$1"
		[ -z "$arg" ] && arg="master.."
		git log --graph "$arg"
		;;

	a)
		wait_for_git_lock

		if [ "$(current_branch)" = "master" ]
		then
			$SELF migrename -n
		fi

		if [ $# = 0 ]
		then
 			git add -Av .
 		else
			git add -Av "$@"
		fi
		$SELF s
		;;
	m)
		wait_for_git_lock
		if [ "$1" ]
		then
 			git commit -m "$1"
 		else
 			git commit -e
 		fi
		propose_push $(current_branch)
		;;
	am)
		wait_for_git_lock
		do_the_adding="yes"
		# --quiet removes output and also turns on correct exit codes
		if git diff --staged --quiet
		then
			true
		else
			git status
			echo
			$JW_CONFIRM_CMD -n "Something is already staged, are you sure you want to stage everything else?" || do_the_adding=""
		fi
		[ "$do_the_adding" ] && $SELF a
		$SELF m "$@"
		;;
	r)
		wait_for_git_lock
		if [ $# = 0 ]
		then
			git checkout -- .
			git clean -f .
		else
			git checkout -- "$@"
			git clean -f -- "$@"
		fi
		;;
	p)
		wait_for_git_lock
		branch=$(current_branch)
		git push origin "$branch"
		;;
	fp)
		wait_for_git_lock
		branch=$(current_branch)
		$JW_CONFIRM_CMD "Do you really want to force push? Can't be good, you know." || exit 1
		git push --force origin "$branch"
		;;
	ok)
		wait_for_git_lock
		$SELF a
		git rebase --continue
		;;
	u)
		wait_for_git_lock
		git pull
		git submodule update --recursive --init
		;;
	ss)
		wait_for_git_lock
		git stash
		;;
	sp)
		wait_for_git_lock
		git stash pop
		;;

	b)
		wait_for_git_lock
		[ -z "$1" ] && crap "You must specify the branch"
		needcreate=""
		git branch --no-color | grep "$1" >/dev/null || needcreate="-b"
		git checkout $needcreate "$1"
		[ -z "$needcreate" ] || mark_branch_date
		;;
	bm)
		wait_for_git_lock
		git rebase --abort >/dev/null 2>/dev/null || true
		git checkout master
		$SELF u
		;;
	g|grab)
		wait_for_git_lock
		git remote update > /dev/null
		norebase="yes"
		if [ "$1" = "-r" ]
		then
			norebase=""
			shift 1
		fi
		branch=$(guess_remote_branch "$1")
		[ "$branch" == 'master' ] && crap "Cannot grab master"
		[ -z "$branch" ] && crap "You must specify the branch"
		[ -z "$(git branch -r | grep "origin/$branch")" ] && crap "No branch $branch in origin"
		# going to master so we can delete current branch
		git checkout master
		# try to delete the branch;
		# error means there was no branch, it should be ignored
		git branch -D "$branch" 2> /dev/null || true
		echo
		echo "== Checking out $branch"
		git checkout -b "$branch" "origin/$branch"
		if [ -z "$norebase" ]
		then
			echo
			echo "== Rebasing to master"
			git rebase master
		fi
		#$SELF sm
		;;
	mr|migrename)
		mp=$(find_migrations_path)
		# skip projects without migrations
		[ "$mp" ] || exit 0

		nocommit=""
		if [ "$1" = "-n" ]
		then
			nocommit="yes"
		fi

		# renaming all new migrations to from NNNNNNNNNNNN_x (timestamp) to NNNN_x
		set +e # prevent empty grep from killing our script
		list="$(ls "$mp" | grep -E '^[0-9]{5}')"
		set -e
		if [ "$list" ]
		then
			if [ -z "$nocommit" ]
			then
				# checking for dirty index/untracked files
				[ "$(git status --porcelain 2>/dev/null)" ] && crap "Cannot rename migrations: there are uncommitted changes"
			fi

			echo "$list" | while read fname
			do
				# finding maximum number in files
				set +e
				last_prefix=$(ls "$mp" | grep -oE '^[0-9]{4}_' | sort -r | head -n1 | grep -oE '[0-9]+')
				set -e
				# removing leading zeros
				[ "$last_prefix" ] && number=$(echo "$last_prefix" | sed 's/^0\+//')
				[ -z "$last_prefix" ] && number="0"
				# making the new filename
				let number+=1
				number=$(printf '%04d' "$number")
				newfname="$number$(echo "$fname" | sed 's/^[0-9]\+//')"
				echo "Renaming $fname to $newfname"
				mv "$mp/$fname" "$mp/$newfname"
			done
			if [ -z "$nocommit" ]
			then
				git add -Av .
				git commit -m "Renaming migrations from timestamps to number prefixes (see #847 for details)"
			fi
		fi
		;;

	rd)
		wait_for_git_lock
		branch="$1"
		[ -z "$branch" ] && branch=$(current_branch)
		git branch -r | grep "origin/$branch" >/dev/null || crap "No branch $branch in origin"
		git push origin :$branch
		;;
	accept-all)
		for ticket in $($JW_TRAC_CMD list-validated); do
			echo
			echo
			echo "Trying to accept ticket $ticket"
			echo
			if $SELF grab $ticket; then
				# merging the branch into master, closing the ticket
				yes | $SELF accept
			fi
		done
		;;
	ac|accept)
		[ "$1" ] && $SELF grab "$1"
		wait_for_git_lock
		branch=$(current_branch)
		echo
		echo "== Current branch is $branch"
		[ "$branch" == "master" ] && crap
		$JW_CONFIRM_CMD "Do you wish to merge this branch into master and then delete the branch?" || exit 0
		echo
		echo "== Renaming migrations"
		$SELF migrename
		echo
		echo "== Switching to master"
		git checkout master
		echo
		echo "== Merging $branch into master"
		git merge --no-ff "$branch"
		echo
		echo "== Pushing master"
		git push origin master
		echo
		echo "== Removing local branch $branch"
		git branch -D "$branch"
		if git branch -r | grep "origin/$branch" >/dev/null
		then
			echo
			echo "== Removing remote branch $branch"
			git push origin :$branch
		fi
		ticket=$(guess_ticket "$branch")
		if [ "$ticket" ] && [ "$JW_TRAC_CMD" ]
		then
			ticket_info=$($JW_TRAC_CMD view "$ticket" | head -n 2)
			if echo "$ticket_info" | head -n 1 | grep -v closed >/dev/null
			then
				echo
				echo "== Trac ticket"
				echo "$ticket_info"
				$JW_CONFIRM_CMD "Do you want to close this ticket now?" && echo " " | $JW_TRAC_CMD save "$ticket" status:closed resolution:fixed
			fi
		fi
		;;

	t)
		require_trac
		ticket=$(current_ticket "$1")
		$JW_TRAC_CMD view "$ticket"
		;;
	te)
		require_trac
		ticket=$(current_ticket "$1")
		tmpf=$(mktemp)
		tmpf2=$(mktemp)
		$JW_TRAC_CMD get "$ticket" > $tmpf
		cp $tmpf $tmpf2
		# counting lines to put cursor at the last one in editor
		lines=$(cat $tmpf | wc -l)
		nano -ti +$lines $tmpf
		if diff $tmpf $tmpf2 >/dev/null
		then
			echo "No changes"
		else
			cat $tmpf | $JW_TRAC_CMD save "$ticket"

			branch=$( [ "$1" ] && echo "$1" || current_branch )
			if [ "$branch" ]
			then
				# touching branch code review
				echo
				$JW_CONFIRM_CMD "Do you want to mark review complete for $branch?" \
 					&& $SELF rw "$ticket"
			fi
		fi
		rm $tmpf $tmpf2
		;;
	fix)
		require_trac
		ticket=$(current_ticket "$1")
		echo "Closing ticket $ticket"
		echo " " | $JW_TRAC_CMD save "$ticket" status:closed resolution:fixed
		;;
	*)
		echo "Unrecognized command: $cmd" >&2
		$JW_CONFIRM_CMD "Do you want to run that with git?" || exit 1
		git "$cmd" "$@"
		;;
esac
