#!/bin/bash

# exit on first error
set -e

# loading variables with settings
source jw-settings

SELF="jw-git-helper"

usage()
{
cat << EOF
Usage: gh command [args]
Information:
  s       git status
  so      git remote show origin
  l       List of all branches. Auto-updates remote list.
  i       Show changes in current branch since master.
  dl      Show diff for last commit in the branch.
  stm     diff --stat, with master by default
  dtm     diff, with master by default
  ltm     log, with master by default
  help    An instruction on using this tool.
Working:
  u       git pull
  ss      git stash
  sp      git stash pop
  r       git checkout --
Committing:
  a       git add
  m       git commit
  am      Commit all local changes.
  p       Push current branch to origin.
  fp      Push current branch to origin (with --force).
  mr [-n] Rename migrations from timestamps to ordered numbers
          (-n is no rename without committing)
Branches:
  b       Switch to a branch, creates it if necessary.
  bm      Switch to master branch.
  g [-n]  Create a local branch from the remote one, then rebase.
          (-n is to skip the rebase part)
          Will overwrite local branch completely.
Manipulation:
  rd      Deletes a remote branch.
  accept  Merge current branch into master, push master,
          then remove the branch from both servers.
Trac:
  t       Show ticket info.
  te      Edit ticket description.
  fix     Close ticket (fixed).
  ta      Change ticket owner according to branch name.
  rw      Touch code review status.
  w       Show review status across all configured repos
EOF
}

show_help()
{
usage
cat << EOF

Working with repositories as a lead programmer:

 1. Look at the list of branches in all repos:

       gh w

    It will show all development branches with review status in colour:
    red = no review, yellow = changed after review, green = reviewed.

 2. If you want to examine a branch, grab it:

       gh g branch_name

    Grab will checkout the branch as it is in origin, discarding any local changes,
    so you can be sure that you're looking at the latest code.

    Grab will also rebase the local branch to master. If rebase fails, you should
    tell the developer to rebase his local copy and push again. If you want to
    merge yourself, don't forget that running grab again will erase your merge.

    You can omit branch name to regrab current branch.

 3. Open the ticket description:

       gh t

    Ticket number is taken from the name of current branch.

 4. Use your IDE and merge tools to examine the changes.

 5. If you do not want to accept the branch, you can edit ticket description
    to tell its owner what is wrong:

       gh te

    Then mark review complete:

       gh rw [review_summary]

    The review summary does not go into the ticket, it is only displayed in output of 'rw',
    so you know what was reviewed and which branches were updated afterwards.

 6. If you want to accept the branch into master, simply type:

       gh accept

    This will merge the branch into master, remove the branch from both local and remote
    servers, and close the ticket as fixed (you will be asked for confirmation).

EOF
}


# die if no args
[ $# = 0 ] && usage && exit 1


# exits with an error message
crap() { # error message
	[ "$1" ] && echo "$1" >&2
	exit 1
}

current_branch() {
	git branch --no-color 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
}

guess_remote_branch() { # [branch name | ticket number]
	# no branch given: take current branch
	[ -z "$1" ] && current_branch && return
	# ticket number: try to find a branch for it
	if [[ "$1" =~ ^[0-9]+$ ]]
	then
		bs=$(git branch -r --no-color 2>/dev/null | sed -e 's/^ *origin\///' | grep -e '^[^ ]\+$' | grep "_${1}_")
		n=$(echo "$bs" | wc -l)
		if [ $n = "1" ]
		then
			echo "$bs"
			return
		fi
	fi
	# nothing is found, returning
	echo "$1"
}

# cuts first numeric sequence from the input
guess_ticket() { # ticket id or branch name
	echo "$1" | egrep -o '[0-9]+' | head -n 1
}

guess_author() { # [branch name]
	branch="$1"
	[ -z "$branch" ] && branch=$(current_branch)
	echo "$branch" | cut -d _ -f 1
}

# Takes input and converts it into ticket id.
# Grabs current branch name if no/empty args given.
# The script will die if no ticket id is found!
current_ticket() { # [ticket id or branch name]
	str="$1"
	[ -z "$str" ] && str=$(current_branch)
	ticket=$(guess_ticket "$str")
	[ -z "$ticket" ] && crap "Need ticket number"
	echo "$ticket"
}

current_project_root() {
	x=$(pwd)
	while [ "$x" != "/" ]
	do
		[ -d "$x/.git" ] && echo "$x" && return
		x=$(dirname "$x")
	done
	crap "Not in a git repository"
}

find_migrations_path() {
	x=$(current_project_root)
	[ -d "$x/$JW_MIGRATIONS_PATH" ] && echo "$x/$JW_MIGRATIONS_PATH" || true # prevent the function from returning 1
}

propose_push() { # branch name
	if [ "$1" ] && $JW_CONFIRM_CMD -n "Do you want to push $1 to origin?"
	then
		git push origin "$1"
	fi
}

wait_for_git_lock() {
	pth="$(current_project_root)"
	lockf="$pth/.git/index.lock"
	if [ -e "$lockf" ]
	then
		echo -ne "Waiting for other process to release git lock.."
		while [ -e "$lockf" ]
		do
			echo -ne "."
			sleep 1
		done
		echo
	fi
}

require_trac() {
	[ "$JW_TRAC_CMD" ] || crap "No trac command specified, see jw-settings"
}

assign_ticket() { # ticket author
	echo "About to save ticket $1"
	echo " " | $JW_TRAC_CMD save "$1" owner:$2
}

cmd="$1"
shift 1

case "$cmd" in
	help)
		show_help
		;;
	s)
		wait_for_git_lock
		git status
		;;
	so)
		wait_for_git_lock
		git remote show origin
		;;
	l)
		wait_for_git_lock
		git remote update >/dev/null
		git branch -a
		;;
	i)
		wait_for_git_lock
		git log -M -C --stat --summary --abbrev-commit  master..
		;;
	dl)
		wait_for_git_lock
		git diff HEAD^..HEAD
		;;
	sm|stm)
		wait_for_git_lock
		arg="$1"
		[ -z "$arg" ] && arg="master.."
		git diff --stat "$arg"
		;;
	dm|dtm)
		wait_for_git_lock
		arg="$1"
		[ -z "$arg" ] && arg="master.."
		git diff "$arg"
		;;
	lm|ltm)
		wait_for_git_lock
		arg="$1"
		[ -z "$arg" ] && arg="master.."
		git log "$arg"
		;;

	a)
		wait_for_git_lock

		if [ "$(current_branch)" = "master" ]
		then
			$SELF migrename -n
		fi

		if [ $# = 0 ]
		then
 			git add -Av .
 		else
			git add -Av "$@"
		fi
		;;
	m)
		wait_for_git_lock
		if [ "$1" ]
		then
 			git commit -m "$1"
 		else
 			git commit -e
 		fi
		propose_push $(current_branch)
		;;
	am)
		wait_for_git_lock
		do_the_adding="yes"
		# --quiet removes output and also turns on correct exit codes
		if git diff --staged --quiet
		then
			true
		else
			git status
			echo
			$JW_CONFIRM_CMD -n "Something is already staged, are you sure you want to stage everything else?" || do_the_adding=""
		fi
		[ "$do_the_adding" ] && $SELF a
		$SELF m "$@"
		;;
	r)
		wait_for_git_lock
		if [ $# = 0 ]
		then
			git checkout -- .
			git clean -f .
		else
			git checkout -- "$@"
			git clean -f -- "$@"
		fi
		;;
	p)
		wait_for_git_lock
		branch=$(current_branch)
		git push origin "$branch"
		;;
	fp)
		wait_for_git_lock
		branch=$(current_branch)
		$JW_CONFIRM_CMD "Do you really want to force push? Can't be good, you know." || exit 1
		git push --force origin "$branch"
		;;
	u)
		wait_for_git_lock
		git pull
		;;
	ss)
		wait_for_git_lock
		git stash
		;;
	sp)
		wait_for_git_lock
		git stash pop
		;;

	b)
		wait_for_git_lock
		[ -z "$1" ] && crap "You must specify the branch"
		needcreate=""
		git branch --no-color | grep "$1" >/dev/null || needcreate="-b"
		git checkout $needcreate "$1"
		;;
	bm)
		wait_for_git_lock
		git rebase --abort >/dev/null 2>/dev/null || true
		git checkout master
		;;
	g|grab)
		wait_for_git_lock
		git remote update > /dev/null
		norebase=""
		if [ "$1" = "-n" ]
		then
			norebase="yes"
			shift 1
		fi
		branch=$(guess_remote_branch "$1")
		[ "$branch" == 'master' ] && crap "Cannot grab master"
		[ -z "$branch" ] && crap "You must specify the branch"
		[ -z "$(git branch -r | grep "origin/$branch")" ] && crap "No branch $branch in origin"
		# going to master so we can delete current branch
		git checkout master
		# try to delete the branch;
		# error means there was no branch, it should be ignored
		git branch -D "$branch" 2> /dev/null || true
		echo
		echo "== Checking out $branch"
		git checkout -b "$branch" "origin/$branch"
		if [ -z "$norebase" ]
		then
			echo
			echo "== Rebasing to master"
			git rebase master
		fi
		$SELF sm
		;;
	mr|migrename)
		mp=$(find_migrations_path)
		# skip projects without migrations
		[ "$mp" ] || exit 0

		nocommit=""
		if [ "$1" = "-n" ]
		then
			nocommit="yes"
		fi

		# renaming all new migrations to from NNNNNNNNNNNN_x (timestamp) to NNNN_x
		set +e # prevent empty grep from killing our script
		list="$(ls "$mp" | grep -E '^[0-9]{5}')"
		set -e
		if [ "$list" ]
		then
			if [ -z "$nocommit" ]
			then
				# checking for dirty index/untracked files
				[ "$(git status --porcelain 2>/dev/null)" ] && crap "Cannot rename migrations: there are uncommitted changes"
			fi

			echo "$list" | while read fname
			do
				# finding maximum number in files
				set +e
				last_prefix=$(ls "$mp" | grep -oE '^[0-9]{4}_' | sort -r | head -n1 | grep -oE '[0-9]+')
				set -e
				# removing leading zeros
				[ "$last_prefix" ] && number=$(echo "$last_prefix" | sed 's/^0\+//')
				[ -z "$last_prefix" ] && number="0"
				# making the new filename
				let number++
				number=$(printf '%04d' "$number")
				newfname="$number$(echo "$fname" | sed 's/^[0-9]\+//')"
				echo "Renaming $fname to $newfname"
				mv "$mp/$fname" "$mp/$newfname"
			done
			if [ -z "$nocommit" ]
			then
				$SELF am "Renaming migrations from timestamps to number prefixes (see #847 for details)"
			fi
		fi
		;;

	rd)
		wait_for_git_lock
		branch="$1"
		[ -z "$branch" ] && branch=$(current_branch)
		git branch -r | grep "origin/$branch" >/dev/null || crap "No branch $branch in origin"
		git push origin :$branch
		;;
	accept)
		wait_for_git_lock
		branch=$(current_branch)
		echo
		echo "== Current branch is $branch"
		[ "$branch" == "master" ] && crap
		$JW_CONFIRM_CMD "Do you wish to merge this branch into master and then delete the branch?" || exit 0
		echo
		echo "== Renaming migrations"
		$SELF migrename
		echo
		echo "== Switching to master"
		git checkout master
		echo
		echo "== Merging $branch into master"
		git merge --no-ff "$branch"
		echo
		echo "== Pushing master"
		git push origin master
		echo
		echo "== Removing local branch $branch"
		git branch -D "$branch"
		if git branch -r | grep "origin/$branch" >/dev/null
		then
			echo
			echo "== Removing remote branch $branch"
			git push origin :$branch
		fi
		ticket=$(guess_ticket "$branch")
		if [ "$ticket" ] && [ "$JW_TRAC_CMD" ]
		then
			ticket_info=$($JW_TRAC_CMD view "$ticket" | head -n 2)
			if echo "$ticket_info" | head -n 1 | grep -v closed >/dev/null
			then
				echo
				echo "== Trac ticket"
				echo "$ticket_info"
				$JW_CONFIRM_CMD "Do you want to close this ticket now?" && echo " " | $JW_TRAC_CMD save "$ticket" status:closed resolution:fixed
			fi
		fi
		;;

	t)
		require_trac
		ticket=$(current_ticket "$1")
		$JW_TRAC_CMD view "$ticket"
		;;
	te)
		require_trac
		ticket=$(current_ticket "$1")
		tmpf=$(mktemp)
		tmpf2=$(mktemp)
		$JW_TRAC_CMD get "$ticket" > $tmpf
		cp $tmpf $tmpf2
		# counting lines to put cursor at the last one in editor
		lines=$(cat $tmpf | wc -l)
		nano -ti +$lines $tmpf
		if diff $tmpf $tmpf2 >/dev/null
		then
			echo "No changes"
		else
			cat $tmpf | $JW_TRAC_CMD save "$ticket"

			branch=$( [ "$1" ] && echo "$1" || current_branch )
			if [ "$branch" ]
			then
				# touching branch code review
				echo
				$JW_CONFIRM_CMD "Do you want to mark review complete for $branch?" \
 					&& $SELF rw "$ticket"

				# reverting ticket back to its owner
				#author=$(guess_author "$branch")
				#if head -n 1 "$tmpf" | grep -v "$author" >/dev/null
				#then
				#	echo
				#	$JW_TRAC_CMD view "$ticket" | head -n 2
				#	if $JW_CONFIRM_CMD "Do you want to assign this ticket to $author?"
				#	then
				#		assign_ticket "$ticket" "$author"
				#	fi
				#fi
			fi
		fi
		rm $tmpf $tmpf2
		;;
	fix)
		require_trac
		ticket=$(current_ticket "$1")
		echo "Closing ticket $ticket"
		echo " " | $JW_TRAC_CMD save "$ticket" status:closed resolution:fixed
		;;
	rw)
		require_trac
		ticket=$(current_ticket "$1")
		echo "Marking ticket $ticket as reviewed"
		$JW_TRAC_CMD mark-review "$ticket"
		;;
	w)
		require_trac
		[ -z "$JW_REVIEWABLE_PROJECTS" ] && crap "No repos configured for reviewing"

		# accumulating report
		report=$(
			echo "$JW_REVIEWABLE_PROJECTS" | while read fld; do
				cd "$fld"
				project=$(basename "$fld")
				echo "project $project"

				# need the sort so grep would not cause exit
				git branch -r --no-color | \
 				cut -d" " -f 3 | cut -d"/" -f 2 | \
 				grep -v '^master$' | grep -v '^HEAD$' | \
 				sort | while read branch; do
					echo "branch $branch"
				done
			done
		)

		# loading tickets info from trac
		tickets=$(echo "$report" | grep ^branch | egrep -o "[0-9]+")
		ticket_info=""
		[ "$tickets" ] && ticket_info=$($JW_TRAC_CMD status-info $tickets)

		echo "$report" | while read line; do
			type=$(echo "$line" | cut -d' ' -f1)
			item=$(echo "$line" | cut -d' ' -f2)
			case "$type" in
				"project")
					project="$item"
					;;
				"branch")
					if [ "$project" ]
					then
						echo
						echo "$project"
						project=""
					fi

					color="white"
					descr=" "
					suffix=""
					ticket=$(guess_ticket "$item")
					if [ "$ticket" ]
					then
						trac_line=$(echo "$ticket_info" | grep "^$ticket " | head -n1)
						if [ "$trac_line" ]
						then
							# ticket changed reviewed pushed merged
							tstatus=$(echo "$trac_line" | cut -d' ' -f2)
							towner=$(echo "$trac_line" | cut -d' ' -f3)
							color="yellow"
							[ "$tstatus" = "pushed" ] && color="blue" && descr="P" && suffix=" (reviewer $towner)"
							[ "$tstatus" = "pushed" ] && [ "$towner" = "agalkin" ] && color="cyan"
							[ "$tstatus" = "reviewed" ] && color="red" && descr="R"
							[ "$tstatus" = "validated" ] && color="green" && descr="V"
						fi
					fi
					echo "$(jw-paint $color " $descr $item$suffix")"
					;;
			esac
		done
		echo
		;;
	ta)
		require_trac
		ticket=$(current_ticket "$1")
		author=$(guess_author)
		$JW_TRAC_CMD view "$ticket" | head -n 2
		$JW_CONFIRM_CMD "Do you want to assign this ticket to $author?" || exit 1
		assign_ticket "$ticket" "$author"
		;;
	*)
		echo "Unrecognized command: $cmd" >&2
		$JW_CONFIRM_CMD "Do you want to run that with git?" || exit 1
		git "$cmd" "$@"
		;;
esac
